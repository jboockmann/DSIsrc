/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
struct node {
   struct node *next ;
   int value ;
};
struct list {
   struct node *head ;
};
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
static struct list *l  ;
void list_add(struct node *n ) ;
void list_add(struct node *n ) 
{ 


  {
  logComment("Function Entered");
  logVarInScope("formal", "n", "struct node *", & n);
  logBlockEntry("sll_8.c", 21);
  n->next = l->head;
  logAssignOffset("sll_8.c", 21, n, "struct node", "*n", & n->next, "struct node *",
                  "n->next", n->next, "struct node", "l->head", 0);
  l->head = n;
  logAssignOffset("sll_8.c", 22, l, "struct list", "*l", & l->head, "struct node *",
                  "l->head", l->head, "struct node", "n", 0);
  logBlockExit("sll_8.c", 22);
  {
  logVarOutOfScope("n", & n);
  {
  logComment("Function Exited");
  return;
  }
  }
}
}
struct node *node_malloc(int item ) 
{ 
  struct node *new ;
  void *tmp ;

  {
  logComment("Function Entered");
  logVarInScope("local", "new", "struct node *", & new);
  logVarInScope("local", "tmp", "void *", & tmp);
  logBlockEntry("sll_8.c", 27);
  tmp = malloc(sizeof(struct node ));
  logAssignNoOffset("sll_8.c", 27, & tmp, "void *", "tmp", tmp, "void", "malloc",
                    1);
  logMallocInfo("sizeof(struct node )", sizeof(struct node ));
  new = (struct node *)tmp;
  logAssignNoOffset("sll_8.c", 27, & new, "struct node *", "new", new, "struct node",
                    "(struct node *)tmp", 0);
  logBlockExit("sll_8.c", 27);
  if ((unsigned long )new == (unsigned long )((struct node *)0)) {
    abort();
    logBlockEntry("", -1);
    dumpVarsOutOfScope();
    logBlockExit("", -1);
  }
  logBlockEntry("sll_8.c", 29);
  new->next = (struct node *)0;
  logAssignOffset("sll_8.c", 29, new, "struct node", "*new", & new->next, "struct node *",
                  "new->next", new->next, "struct node", "(struct node *)0", 0);
  new->value = item;
  logBlockExit("sll_8.c", 30);
  {
  logVarOutOfScope("new", & new);
  logVarOutOfScope("tmp", & tmp);
  {
  logComment("Function Exited");
  return (new);
  }
  }
}
}
int main(void) 
{ 
  void *tmp ;
  struct node *n1 ;
  struct node *tmp___0 ;
  struct node *n2 ;
  struct node *tmp___1 ;
  struct node *n3 ;
  struct node *tmp___2 ;

  {
  logComment("Function Entered");
  logVarInScope("local", "tmp", "void *", & tmp);
  logVarInScope("local", "n1", "struct node *", & n1);
  logVarInScope("local", "tmp___0", "struct node *", & tmp___0);
  logVarInScope("local", "n2", "struct node *", & n2);
  logVarInScope("local", "tmp___1", "struct node *", & tmp___1);
  logVarInScope("local", "n3", "struct node *", & n3);
  logVarInScope("local", "tmp___2", "struct node *", & tmp___2);
  logBlockEntry("sll_8.c", 37);
  tmp = malloc(sizeof(struct list ));
  logAssignNoOffset("sll_8.c", 37, & tmp, "void *", "tmp", tmp, "void", "malloc",
                    1);
  logMallocInfo("sizeof(struct list )", sizeof(struct list ));
  l = (struct list *)tmp;
  logAssignNoOffset("sll_8.c", 37, & l, "struct list *", "l", l, "struct list", "(struct list *)tmp",
                    0);
  logBlockExit("sll_8.c", 37);
  if ((unsigned long )l == (unsigned long )((struct list *)0)) {
    abort();
    logBlockEntry("", -1);
    dumpVarsOutOfScope();
    logBlockExit("", -1);
  }
  logBlockEntry("sll_8.c", 39);
  l->head = (struct node *)0;
  logAssignOffset("sll_8.c", 39, l, "struct list", "*l", & l->head, "struct node *",
                  "l->head", l->head, "struct node", "(struct node *)0", 0);
  logBlockExit("sll_8.c", 40);
  tmp___0 = node_malloc(1);
  logBlockEntry("sll_8.c", 40);
  logAssignNoOffset("sll_8.c", 40, & tmp___0, "struct node *", "tmp___0", tmp___0,
                    "struct node", "node_malloc", 0);
  dumpVarsOutOfScope();
  n1 = tmp___0;
  logAssignNoOffset("sll_8.c", 40, & n1, "struct node *", "n1", n1, "struct node",
                    "tmp___0", 0);
  logBlockExit("sll_8.c", 41);
  tmp___1 = node_malloc(2);
  logBlockEntry("sll_8.c", 41);
  logAssignNoOffset("sll_8.c", 41, & tmp___1, "struct node *", "tmp___1", tmp___1,
                    "struct node", "node_malloc", 0);
  dumpVarsOutOfScope();
  n2 = tmp___1;
  logAssignNoOffset("sll_8.c", 41, & n2, "struct node *", "n2", n2, "struct node",
                    "tmp___1", 0);
  logBlockExit("sll_8.c", 42);
  tmp___2 = node_malloc(3);
  logBlockEntry("sll_8.c", 42);
  logAssignNoOffset("sll_8.c", 42, & tmp___2, "struct node *", "tmp___2", tmp___2,
                    "struct node", "node_malloc", 0);
  dumpVarsOutOfScope();
  n3 = tmp___2;
  logAssignNoOffset("sll_8.c", 42, & n3, "struct node *", "n3", n3, "struct node",
                    "tmp___2", 0);
  logBlockExit("sll_8.c", 43);
  list_add(n1);
  logBlockEntry("", -1);
  dumpVarsOutOfScope();
  logBlockExit("sll_8.c", 44);
  list_add(n2);
  logBlockEntry("", -1);
  dumpVarsOutOfScope();
  logBlockExit("sll_8.c", 45);
  list_add(n3);
  logBlockEntry("", -1);
  dumpVarsOutOfScope();
  logBlockExit("", -1);
  {
  logVarOutOfScope("tmp", & tmp);
  logVarOutOfScope("n1", & n1);
  logVarOutOfScope("tmp___0", & tmp___0);
  logVarOutOfScope("n2", & n2);
  logVarOutOfScope("tmp___1", & tmp___1);
  logVarOutOfScope("n3", & n3);
  logVarOutOfScope("tmp___2", & tmp___2);
  {
  logComment("Function Exited");
  return (0);
  }
  }
}
}

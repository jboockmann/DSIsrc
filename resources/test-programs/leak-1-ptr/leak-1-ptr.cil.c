/* Generated by CIL v. 1.7.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
struct node {
   int payload ;
   struct node *next ;
   struct node *link ;
};
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
int const   NUM_OPS_WEISS_STACK  ;
int const   INSERT_PROB_WEISS_STACK  ;
int const   DELETE_PROB_WEISS_STACK  ;
int const   NUM_OPS_GALILEO_QUEUE  ;
int const   INSERT_PROB_GALILEO_QUEUE  ;
int const   DELETE_PROB_GALILEO_QUEUE  ;
int const   OPID_SLL_INSERT  ;
int const   OPID_SLL_REMOVE  ;
int const   OPID_DLL_INSERT  ;
int const   OPID_DLL_REMOVE  ;
int const   OPID_SLL_INSERT_FRONT  ;
int const   OPID_SLL_INSERT_MIDDLE  ;
int const   OPID_SLL_INSERT_BACK  ;
int const   OPID_SLL_INSERT_FRONT_DH  ;
int const   OPID_SLL_REMOVE_FRONT  ;
int const   OPID_SLL_REMOVE_MIDDLE  ;
int const   OPID_SLL_REMOVE_BACK  ;
int const   OPID_SLL_REMOVE_FRONT_DH  ;
int const   OPID_DLL_INSERT_FRONT  ;
int const   OPID_DLL_INSERT_MIDDLE  ;
int const   OPID_DLL_INSERT_BACK  ;
int const   OPID_DLL_INSERT_FRONT_DH  ;
int const   OPID_DLL_REMOVE_FRONT  ;
int const   OPID_DLL_REMOVE_MIDDLE  ;
int const   OPID_DLL_REMOVE_BACK  ;
int const   OPID_DLL_REMOVE_FRONT_DH  ;
int const   OPID_BTREE_INSERT  ;
int const   OPID_BTREE_REMOVE  ;
char const   *operationLocationStrings[5]  ;
struct node *insert(struct node *cur_elem ) 
{ 
  struct node *ret_val ;
  void *tmp ;
  void *tmp___0 ;

  {
  logComment("Function Entered");
  logBlockEntry("leak-1-ptr.c", 21);
  ret_val = (struct node *)((void *)0);
  logAssignNoOffset("leak-1-ptr.c", 21, & ret_val, "struct node *", "ret_val", ret_val,
                    "struct node", "(struct node *)((void *)0)", 0);
  logBlockExit("leak-1-ptr.c", 21);
  if ((unsigned long )cur_elem != (unsigned long )((void *)0)) {
    logBlockEntry("leak-1-ptr.c", 23);
    tmp = malloc(sizeof(struct node ));
    logAssignNoOffset("leak-1-ptr.c", 23, & tmp, "void *", "tmp", tmp, "void", "malloc",
                      1);
    logMallocInfo("sizeof(struct node )", sizeof(struct node ));
    cur_elem->next = (struct node *)tmp;
    logAssignOffset("leak-1-ptr.c", 23, cur_elem, "struct node", "*cur_elem", & cur_elem->next,
                    "struct node *", "cur_elem->next", cur_elem->next, "struct node",
                    "(struct node *)tmp", 0);
    logBlockExit("leak-1-ptr.c", 23);
    if ((unsigned long )cur_elem->next == (unsigned long )((void *)0)) {
      printf((char const   * __restrict  )"Error: No space left. Exiting.");
      exit(1);
    }
    logBlockEntry("leak-1-ptr.c", 28);
    (cur_elem->next)->next = (struct node *)((void *)0);
    logAssignOffset("leak-1-ptr.c", 28, cur_elem->next, "struct node", "*(cur_elem->next)",
                    & (cur_elem->next)->next, "struct node *", "(cur_elem->next)->next",
                    (cur_elem->next)->next, "struct node", "(struct node *)((void *)0)",
                    0);
    ret_val = cur_elem->next;
    logAssignNoOffset("leak-1-ptr.c", 29, & ret_val, "struct node *", "ret_val", ret_val,
                      "struct node", "cur_elem->next", 0);
    logBlockExit("leak-1-ptr.c", 29);
  } else {
    logBlockEntry("leak-1-ptr.c", 32);
    tmp___0 = malloc(sizeof(struct node ));
    logAssignNoOffset("leak-1-ptr.c", 32, & tmp___0, "void *", "tmp___0", tmp___0,
                      "void", "malloc", 1);
    logMallocInfo("sizeof(struct node )", sizeof(struct node ));
    cur_elem = (struct node *)tmp___0;
    logAssignNoOffset("leak-1-ptr.c", 32, & cur_elem, "struct node *", "cur_elem",
                      cur_elem, "struct node", "(struct node *)tmp___0", 0);
    logBlockExit("leak-1-ptr.c", 32);
    if ((unsigned long )cur_elem == (unsigned long )((void *)0)) {
      printf((char const   * __restrict  )"Error: No space left. Exiting.");
      exit(1);
    }
    logBlockEntry("leak-1-ptr.c", 37);
    cur_elem->next = (struct node *)((void *)0);
    logAssignOffset("leak-1-ptr.c", 37, cur_elem, "struct node", "*cur_elem", & cur_elem->next,
                    "struct node *", "cur_elem->next", cur_elem->next, "struct node",
                    "(struct node *)((void *)0)", 0);
    ret_val = cur_elem;
    logAssignNoOffset("leak-1-ptr.c", 38, & ret_val, "struct node *", "ret_val", ret_val,
                      "struct node", "cur_elem", 0);
    logBlockExit("leak-1-ptr.c", 38);
  }
  {
  logVarOutOfScope("cur_elem", & cur_elem);
  logVarOutOfScope("ret_val", & ret_val);
  logVarOutOfScope("tmp", & tmp);
  logVarOutOfScope("tmp___0", & tmp___0);
  {
  logComment("Function Exited");
  return (ret_val);
  }
  }
}
}
int main(int argc , char **argv ) 
{ 
  struct node *head ;
  struct node *iter ;
  int i ;

  {
  logComment("Function Entered");
  logBlockEntry("leak-1-ptr.c", 44);
  head = (struct node *)((void *)0);
  logAssignNoOffset("leak-1-ptr.c", 44, & head, "struct node *", "head", head, "struct node",
                    "(struct node *)((void *)0)", 0);
  i = 0;
  logBlockExit("leak-1-ptr.c", 50);
  head = insert(head);
  logBlockEntry("leak-1-ptr.c", 50);
  logAssignNoOffset("leak-1-ptr.c", 50, & head, "struct node *", "head", head, "struct node",
                    "insert", 0);
  iter = head;
  logAssignNoOffset("leak-1-ptr.c", 51, & iter, "struct node *", "iter", iter, "struct node",
                    "head", 0);
  iter->payload = i;
  logBlockExit("leak-1-ptr.c", 52);
  while (i < 5) {
    logComment("Loop-iteration-start_leak-1-ptr.c_53");
    {
    printf((char const   * __restrict  )"Inserting element(%d)\n", i);
    iter = insert(iter);
    logBlockEntry("leak-1-ptr.c", 55);
    logAssignNoOffset("leak-1-ptr.c", 55, & iter, "struct node *", "iter", iter, "struct node",
                      "insert", 0);
    iter->payload = i;
    i ++;
    logBlockExit("leak-1-ptr.c", 53);
    }
    logComment("Loop-iteration-end");
  }
  logBlockEntry("leak-1-ptr.c", 60);
  i = 0;
  iter = head;
  logAssignNoOffset("leak-1-ptr.c", 61, & iter, "struct node *", "iter", iter, "struct node",
                    "head", 0);
  logBlockExit("leak-1-ptr.c", 61);
  while (i < 3) {
    logComment("Loop-iteration-start_leak-1-ptr.c_62");
    {
    printf((char const   * __restrict  )"Forwarding element(%d)\n", i);
    logBlockEntry("leak-1-ptr.c", 64);
    iter = iter->next;
    logAssignNoOffset("leak-1-ptr.c", 64, & iter, "struct node *", "iter", iter, "struct node",
                      "iter->next", 0);
    i ++;
    logBlockExit("leak-1-ptr.c", 62);
    }
    logComment("Loop-iteration-end");
  }
  logBlockEntry("leak-1-ptr.c", 68);
  (iter->next)->link = (struct node *)((void *)0);
  logAssignOffset("leak-1-ptr.c", 68, iter->next, "struct node", "*(iter->next)",
                  & (iter->next)->link, "struct node *", "(iter->next)->link", (iter->next)->link,
                  "struct node", "(struct node *)((void *)0)", 0);
  logBlockExit("leak-1-ptr.c", 69);
  (iter->next)->link = insert((iter->next)->link);
  logBlockEntry("leak-1-ptr.c", 69);
  logAssignOffset("leak-1-ptr.c", 69, iter->next, "struct node", "*(iter->next)",
                  & (iter->next)->link, "struct node *", "(iter->next)->link", (iter->next)->link,
                  "struct node", "insert", 0);
  logBlockExit("leak-1-ptr.c", 70);
  ((iter->next)->link)->next = insert(((iter->next)->link)->next);
  logBlockEntry("leak-1-ptr.c", 70);
  logAssignOffset("leak-1-ptr.c", 70, (iter->next)->link, "struct node", "*((iter->next)->link)",
                  & ((iter->next)->link)->next, "struct node *", "((iter->next)->link)->next",
                  ((iter->next)->link)->next, "struct node", "insert", 0);
  (((iter->next)->link)->next)->next = iter;
  logAssignOffset("leak-1-ptr.c", 72, ((iter->next)->link)->next, "struct node", "*(((iter->next)->link)->next)",
                  & (((iter->next)->link)->next)->next, "struct node *", "(((iter->next)->link)->next)->next",
                  (((iter->next)->link)->next)->next, "struct node", "iter", 0);
  iter->next = (struct node *)((void *)0);
  logAssignOffset("leak-1-ptr.c", 75, iter, "struct node", "*iter", & iter->next,
                  "struct node *", "iter->next", iter->next, "struct node", "(struct node *)((void *)0)",
                  0);
  iter = head;
  logAssignNoOffset("leak-1-ptr.c", 78, & iter, "struct node *", "iter", iter, "struct node",
                    "head", 0);
  logBlockExit("leak-1-ptr.c", 78);
  while ((unsigned long )iter != (unsigned long )((void *)0)) {
    logComment("Loop-iteration-start_leak-1-ptr.c_79");
    {
    printf((char const   * __restrict  )"Freeing element\n");
    logBlockEntry("leak-1-ptr.c", 81);
    head = iter->next;
    logAssignNoOffset("leak-1-ptr.c", 81, & head, "struct node *", "head", head, "struct node",
                      "iter->next", 0);
    logFree("leak-1-ptr.c", 82, "(void *)iter", (void *)iter);
    free((void *)iter);
    iter = head;
    logAssignNoOffset("leak-1-ptr.c", 83, & iter, "struct node *", "iter", iter, "struct node",
                      "head", 0);
    logBlockExit("leak-1-ptr.c", 83);
    }
    logComment("Loop-iteration-end");
  }
  {
  logVarOutOfScope("argv", & argv);
  logVarOutOfScope("head", & head);
  logVarOutOfScope("iter", & iter);
  {
  logComment("Function Exited");
  return (0);
  }
  }
}
}

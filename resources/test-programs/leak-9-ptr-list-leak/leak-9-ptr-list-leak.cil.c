/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
struct node {
   int info ;
   struct node *next ;
};
typedef struct node node;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
int const   NUM_OPS_WEISS_STACK  ;
int const   INSERT_PROB_WEISS_STACK  ;
int const   DELETE_PROB_WEISS_STACK  ;
int const   NUM_OPS_GALILEO_QUEUE  ;
int const   INSERT_PROB_GALILEO_QUEUE  ;
int const   DELETE_PROB_GALILEO_QUEUE  ;
int const   OPID_SLL_INSERT  ;
int const   OPID_SLL_REMOVE  ;
int const   OPID_DLL_INSERT  ;
int const   OPID_DLL_REMOVE  ;
int const   OPID_SLL_INSERT_FRONT  ;
int const   OPID_SLL_INSERT_MIDDLE  ;
int const   OPID_SLL_INSERT_BACK  ;
int const   OPID_SLL_INSERT_FRONT_DH  ;
int const   OPID_SLL_REMOVE_FRONT  ;
int const   OPID_SLL_REMOVE_MIDDLE  ;
int const   OPID_SLL_REMOVE_BACK  ;
int const   OPID_SLL_REMOVE_FRONT_DH  ;
int const   OPID_DLL_INSERT_FRONT  ;
int const   OPID_DLL_INSERT_MIDDLE  ;
int const   OPID_DLL_INSERT_BACK  ;
int const   OPID_DLL_INSERT_FRONT_DH  ;
int const   OPID_DLL_REMOVE_FRONT  ;
int const   OPID_DLL_REMOVE_MIDDLE  ;
int const   OPID_DLL_REMOVE_BACK  ;
int const   OPID_DLL_REMOVE_FRONT_DH  ;
int const   OPID_BTREE_INSERT  ;
int const   OPID_BTREE_REMOVE  ;
char const   *operationLocationStrings[5]  ;
node *inserthead(node *head , int a ) ;
node *inserttail(node *head , int a ) ;
node *deletemultiples(node *head , int a ) ;
void printlist(node *head ) ;
void freelist(node *head ) ;
int main(void) 
{ 
  node *head1 ;
  int i ;

  {
  logComment("Function Entered");
  logVarInScope("local", "head1", "node *", & head1);
  logBlockEntry("leak-9-ptr-list-leak.c", 25);
  head1 = (node *)((void *)0);
  logAssignNoOffset("leak-9-ptr-list-leak.c", 25, & head1, "struct node *", "head1",
                    head1, "struct node", "(node *)((void *)0)", 0);
  i = 2;
  logBlockExit("leak-9-ptr-list-leak.c", 28);
  while (i <= 50) {
    logComment("Loop-iteration-start_leak-9-ptr-list-leak.c_28");
    {
    head1 = inserttail(head1, i);
    logBlockEntry("leak-9-ptr-list-leak.c", 29);
    logAssignNoOffset("leak-9-ptr-list-leak.c", 29, & head1, "struct node *", "head1",
                      head1, "struct node", "inserttail", 0);
    dumpVarsOutOfScope();
    i ++;
    logBlockExit("leak-9-ptr-list-leak.c", 28);
    }
    logComment("Loop-iteration-end");
  }
  i = 2;
  while (i <= 16) {
    logComment("Loop-iteration-start_leak-9-ptr-list-leak.c_31");
    {
    head1 = deletemultiples(head1, i);
    logBlockEntry("leak-9-ptr-list-leak.c", 32);
    logAssignNoOffset("leak-9-ptr-list-leak.c", 32, & head1, "struct node *", "head1",
                      head1, "struct node", "deletemultiples", 0);
    dumpVarsOutOfScope();
    i ++;
    logBlockExit("leak-9-ptr-list-leak.c", 31);
    }
    logComment("Loop-iteration-end");
  }
  printlist(head1);
  logBlockEntry("", -1);
  dumpVarsOutOfScope();
  logBlockExit("leak-9-ptr-list-leak.c", 35);
  freelist(head1);
  logBlockEntry("", -1);
  dumpVarsOutOfScope();
  logBlockExit("", -1);
  {
  logVarOutOfScope("head1", & head1);
  {
  logComment("Function Exited");
  return (0);
  }
  }
}
}
node *inserthead(node *head , int a ) 
{ 
  node *ptr ;
  void *tmp ;

  {
  logComment("Function Entered");
  logVarInScope("formal", "head", "node *", & head);
  logVarInScope("local", "ptr", "node *", & ptr);
  logVarInScope("local", "tmp", "void *", & tmp);
  logBlockEntry("leak-9-ptr-list-leak.c", 41);
  tmp = malloc(sizeof(node ));
  logAssignNoOffset("leak-9-ptr-list-leak.c", 41, & tmp, "void *", "tmp", tmp, "void",
                    "malloc", 1);
  logMallocInfo("sizeof(node )", sizeof(node ));
  ptr = (node *)tmp;
  logAssignNoOffset("leak-9-ptr-list-leak.c", 41, & ptr, "struct node *", "ptr", ptr,
                    "struct node", "(node *)tmp", 0);
  ptr->info = a;
  ptr->next = head;
  logAssignOffset("leak-9-ptr-list-leak.c", 43, ptr, "struct node", "*ptr", & ptr->next,
                  "struct node *", "ptr->next", ptr->next, "struct node", "head",
                  0);
  logBlockExit("leak-9-ptr-list-leak.c", 43);
  {
  logVarOutOfScope("head", & head);
  logVarOutOfScope("ptr", & ptr);
  logVarOutOfScope("tmp", & tmp);
  {
  logComment("Function Exited");
  return (ptr);
  }
  }
}
}
node *inserttail(node *head , int a ) 
{ 
  node *ptr ;
  node *ptr2 ;
  void *tmp ;

  {
  logComment("Function Entered");
  logVarInScope("formal", "head", "node *", & head);
  logVarInScope("local", "ptr", "node *", & ptr);
  logVarInScope("local", "ptr2", "node *", & ptr2);
  logVarInScope("local", "tmp", "void *", & tmp);
  logBlockEntry("leak-9-ptr-list-leak.c", 50);
  ptr2 = head;
  logAssignNoOffset("leak-9-ptr-list-leak.c", 50, & ptr2, "struct node *", "ptr2",
                    ptr2, "struct node", "head", 0);
  tmp = malloc(sizeof(node ));
  logAssignNoOffset("leak-9-ptr-list-leak.c", 52, & tmp, "void *", "tmp", tmp, "void",
                    "malloc", 1);
  logMallocInfo("sizeof(node )", sizeof(node ));
  ptr = (node *)tmp;
  logAssignNoOffset("leak-9-ptr-list-leak.c", 52, & ptr, "struct node *", "ptr", ptr,
                    "struct node", "(node *)tmp", 0);
  ptr->info = a;
  ptr->next = (struct node *)((void *)0);
  logAssignOffset("leak-9-ptr-list-leak.c", 54, ptr, "struct node", "*ptr", & ptr->next,
                  "struct node *", "ptr->next", ptr->next, "struct node", "(struct node *)((void *)0)",
                  0);
  logBlockExit("leak-9-ptr-list-leak.c", 54);
  if ((unsigned long )head == (unsigned long )((void *)0)) {
    {
    logVarOutOfScope("head", & head);
    logVarOutOfScope("ptr", & ptr);
    logVarOutOfScope("ptr2", & ptr2);
    logVarOutOfScope("tmp", & tmp);
    {
    logComment("Function Exited");
    return (ptr);
    }
    }
  } else
  if ((unsigned long )head->next == (unsigned long )((void *)0)) {
    logBlockEntry("leak-9-ptr-list-leak.c", 59);
    head->next = ptr;
    logAssignOffset("leak-9-ptr-list-leak.c", 59, head, "struct node", "*head", & head->next,
                    "struct node *", "head->next", head->next, "struct node", "ptr",
                    0);
    logBlockExit("leak-9-ptr-list-leak.c", 59);
    {
    logVarOutOfScope("head", & head);
    logVarOutOfScope("ptr", & ptr);
    logVarOutOfScope("ptr2", & ptr2);
    logVarOutOfScope("tmp", & tmp);
    {
    logComment("Function Exited");
    return (head);
    }
    }
  }
  while ((unsigned long )head->next != (unsigned long )((void *)0)) {
    logComment("Loop-iteration-start_leak-9-ptr-list-leak.c_62");
    {
    logBlockEntry("leak-9-ptr-list-leak.c", 63);
    head = head->next;
    logAssignNoOffset("leak-9-ptr-list-leak.c", 63, & head, "struct node *", "head",
                      head, "struct node", "head->next", 0);
    logBlockExit("leak-9-ptr-list-leak.c", 63);
    }
    logComment("Loop-iteration-end");
  }
  logBlockEntry("leak-9-ptr-list-leak.c", 65);
  head->next = ptr;
  logAssignOffset("leak-9-ptr-list-leak.c", 65, head, "struct node", "*head", & head->next,
                  "struct node *", "head->next", head->next, "struct node", "ptr",
                  0);
  logBlockExit("leak-9-ptr-list-leak.c", 65);
  {
  logVarOutOfScope("head", & head);
  logVarOutOfScope("ptr", & ptr);
  logVarOutOfScope("ptr2", & ptr2);
  logVarOutOfScope("tmp", & tmp);
  {
  logComment("Function Exited");
  return (ptr2);
  }
  }
}
}
void printlist(node *head ) 
{ 


  {
  logComment("Function Entered");
  logVarInScope("formal", "head", "node *", & head);
  while ((unsigned long )head != (unsigned long )((void *)0)) {
    logComment("Loop-iteration-start_leak-9-ptr-list-leak.c_70");
    {
    printf((char const   * __restrict  )"%i ", head->info);
    logBlockEntry("leak-9-ptr-list-leak.c", 72);
    head = head->next;
    logAssignNoOffset("leak-9-ptr-list-leak.c", 72, & head, "struct node *", "head",
                      head, "struct node", "head->next", 0);
    logBlockExit("leak-9-ptr-list-leak.c", 72);
    }
    logComment("Loop-iteration-end");
  }
  printf((char const   * __restrict  )"\n");
  {
  logVarOutOfScope("head", & head);
  {
  logComment("Function Exited");
  return;
  }
  }
}
}
void freelist(node *head ) 
{ 
  node *ptr ;

  {
  logComment("Function Entered");
  logVarInScope("formal", "head", "node *", & head);
  logVarInScope("local", "ptr", "node *", & ptr);
  logBlockEntry("leak-9-ptr-list-leak.c", 78);
  ptr = head;
  logAssignNoOffset("leak-9-ptr-list-leak.c", 78, & ptr, "struct node *", "ptr", ptr,
                    "struct node", "head", 0);
  logBlockExit("leak-9-ptr-list-leak.c", 78);
  while ((unsigned long )head != (unsigned long )((void *)0)) {
    logComment("Loop-iteration-start_leak-9-ptr-list-leak.c_79");
    {
    logBlockEntry("leak-9-ptr-list-leak.c", 80);
    head = head->next;
    logAssignNoOffset("leak-9-ptr-list-leak.c", 80, & head, "struct node *", "head",
                      head, "struct node", "head->next", 0);
    logFree("leak-9-ptr-list-leak.c", 81, "(void *)ptr", (void *)ptr);
    free((void *)ptr);
    ptr = head;
    logAssignNoOffset("leak-9-ptr-list-leak.c", 82, & ptr, "struct node *", "ptr",
                      ptr, "struct node", "head", 0);
    logBlockExit("leak-9-ptr-list-leak.c", 82);
    }
    logComment("Loop-iteration-end");
  }
  {
  logVarOutOfScope("head", & head);
  logVarOutOfScope("ptr", & ptr);
  {
  logComment("Function Exited");
  return;
  }
  }
}
}
node *deletemultiples(node *head , int a ) 
{ 
  node *ptr ;
  node *temp ;

  {
  logComment("Function Entered");
  logVarInScope("formal", "head", "node *", & head);
  logVarInScope("local", "ptr", "node *", & ptr);
  logVarInScope("local", "temp", "node *", & temp);
  logBlockEntry("leak-9-ptr-list-leak.c", 87);
  ptr = head;
  logAssignNoOffset("leak-9-ptr-list-leak.c", 87, & ptr, "struct node *", "ptr", ptr,
                    "struct node", "head", 0);
  temp = head;
  logAssignNoOffset("leak-9-ptr-list-leak.c", 87, & temp, "struct node *", "temp",
                    temp, "struct node", "head", 0);
  logBlockExit("leak-9-ptr-list-leak.c", 87);
  while ((unsigned long )ptr != (unsigned long )((void *)0)) {
    logComment("Loop-iteration-start_leak-9-ptr-list-leak.c_89");
    {
    if (ptr->info % a > 0) {
      logBlockEntry("leak-9-ptr-list-leak.c", 91);
      ptr = ptr->next;
      logAssignNoOffset("leak-9-ptr-list-leak.c", 91, & ptr, "struct node *", "ptr",
                        ptr, "struct node", "ptr->next", 0);
      temp = temp->next;
      logAssignNoOffset("leak-9-ptr-list-leak.c", 92, & temp, "struct node *", "temp",
                        temp, "struct node", "temp->next", 0);
      logBlockExit("leak-9-ptr-list-leak.c", 92);
    } else {
      logBlockEntry("leak-9-ptr-list-leak.c", 95);
      ptr = ptr->next;
      logAssignNoOffset("leak-9-ptr-list-leak.c", 95, & ptr, "struct node *", "ptr",
                        ptr, "struct node", "ptr->next", 0);
      temp->next = ptr;
      logAssignOffset("leak-9-ptr-list-leak.c", 96, temp, "struct node", "*temp",
                      & temp->next, "struct node *", "temp->next", temp->next, "struct node",
                      "ptr", 0);
      logBlockExit("leak-9-ptr-list-leak.c", 96);
    }
    }
    logComment("Loop-iteration-end");
  }
  {
  logVarOutOfScope("head", & head);
  logVarOutOfScope("ptr", & ptr);
  logVarOutOfScope("temp", & temp);
  {
  logComment("Function Exited");
  return (head);
  }
  }
}
}

/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
struct DLL {
   struct DLL *next ;
   struct DLL *prev ;
};
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
int const   NUM_OPS_WEISS_STACK  ;
int const   INSERT_PROB_WEISS_STACK  ;
int const   DELETE_PROB_WEISS_STACK  ;
int const   NUM_OPS_GALILEO_QUEUE  ;
int const   INSERT_PROB_GALILEO_QUEUE  ;
int const   DELETE_PROB_GALILEO_QUEUE  ;
int const   OPID_SLL_INSERT  ;
int const   OPID_SLL_REMOVE  ;
int const   OPID_DLL_INSERT  ;
int const   OPID_DLL_REMOVE  ;
int const   OPID_SLL_INSERT_FRONT  ;
int const   OPID_SLL_INSERT_MIDDLE  ;
int const   OPID_SLL_INSERT_BACK  ;
int const   OPID_SLL_INSERT_FRONT_DH  ;
int const   OPID_SLL_REMOVE_FRONT  ;
int const   OPID_SLL_REMOVE_MIDDLE  ;
int const   OPID_SLL_REMOVE_BACK  ;
int const   OPID_SLL_REMOVE_FRONT_DH  ;
int const   OPID_DLL_INSERT_FRONT  ;
int const   OPID_DLL_INSERT_MIDDLE  ;
int const   OPID_DLL_INSERT_BACK  ;
int const   OPID_DLL_INSERT_FRONT_DH  ;
int const   OPID_DLL_REMOVE_FRONT  ;
int const   OPID_DLL_REMOVE_MIDDLE  ;
int const   OPID_DLL_REMOVE_BACK  ;
int const   OPID_DLL_REMOVE_FRONT_DH  ;
int const   OPID_BTREE_INSERT  ;
int const   OPID_BTREE_REMOVE  ;
char const   *operationLocationStrings[5]  ;
int insert_node(struct DLL *prev , struct DLL *cur , struct DLL *next ) 
{ 


  {
  logComment("Function Entered");
  logVarInScope("formal", "prev", "struct DLL *", & prev);
  logVarInScope("formal", "cur", "struct DLL *", & cur);
  logVarInScope("formal", "next", "struct DLL *", & next);
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
    {
    logVarOutOfScope("prev", & prev);
    logVarOutOfScope("cur", & cur);
    logVarOutOfScope("next", & next);
    {
    logComment("Function Exited");
    return (1);
    }
    }
  } else
  if ((unsigned long )cur == (unsigned long )((void *)0)) {
    {
    logVarOutOfScope("prev", & prev);
    logVarOutOfScope("cur", & cur);
    logVarOutOfScope("next", & next);
    {
    logComment("Function Exited");
    return (1);
    }
    }
  }
  logBlockEntry("leak-6-ptr.c", 23);
  prev->next = cur;
  logAssignOffset("leak-6-ptr.c", 23, prev, "struct DLL", "*prev", & prev->next, "struct DLL *",
                  "prev->next", prev->next, "struct DLL", "cur", 0);
  logBlockExit("leak-6-ptr.c", 23);
  if ((unsigned long )next != (unsigned long )((void *)0)) {
    logBlockEntry("leak-6-ptr.c", 25);
    next->prev = cur;
    logAssignOffset("leak-6-ptr.c", 25, next, "struct DLL", "*next", & next->prev,
                    "struct DLL *", "next->prev", next->prev, "struct DLL", "cur",
                    0);
    logBlockExit("leak-6-ptr.c", 25);
  }
  logBlockEntry("leak-6-ptr.c", 29);
  cur->prev = prev;
  logAssignOffset("leak-6-ptr.c", 29, cur, "struct DLL", "*cur", & cur->prev, "struct DLL *",
                  "cur->prev", cur->prev, "struct DLL", "prev", 0);
  cur->next = next;
  logAssignOffset("leak-6-ptr.c", 30, cur, "struct DLL", "*cur", & cur->next, "struct DLL *",
                  "cur->next", cur->next, "struct DLL", "next", 0);
  next = (struct DLL *)((void *)0);
  logAssignNoOffset("leak-6-ptr.c", 33, & next, "struct DLL *", "next", next, "struct DLL",
                    "(struct DLL *)((void *)0)", 0);
  cur = next;
  logAssignNoOffset("leak-6-ptr.c", 33, & cur, "struct DLL *", "cur", cur, "struct DLL",
                    "next", 0);
  prev = cur;
  logAssignNoOffset("leak-6-ptr.c", 33, & prev, "struct DLL *", "prev", prev, "struct DLL",
                    "cur", 0);
  logBlockExit("leak-6-ptr.c", 33);
  {
  logVarOutOfScope("prev", & prev);
  logVarOutOfScope("cur", & cur);
  logVarOutOfScope("next", & next);
  {
  logComment("Function Exited");
  return (0);
  }
  }
}
}
struct DLL *malloc_node(void) 
{ 
  void *tmp ;

  {
  logComment("Function Entered");
  logVarInScope("local", "tmp", "void *", & tmp);
  logBlockEntry("leak-6-ptr.c", 39);
  tmp = malloc(sizeof(struct DLL ));
  logAssignNoOffset("leak-6-ptr.c", 39, & tmp, "void *", "tmp", tmp, "void", "malloc",
                    1);
  logMallocInfo("sizeof(struct DLL )", sizeof(struct DLL ));
  logBlockExit("leak-6-ptr.c", 39);
  {
  logVarOutOfScope("tmp", & tmp);
  {
  logComment("Function Exited");
  return ((struct DLL *)tmp);
  }
  }
}
}
int main(int argc , char **argv ) 
{ 
  struct DLL *head ;
  struct DLL *iter ;
  struct DLL *new ;
  int dll_len ;
  int dll_insert ;
  void *tmp ;
  int i ;
  int i___0 ;

  {
  logComment("Function Entered");
  logVarInScope("formal", "argv", "char **", & argv);
  logVarInScope("local", "head", "struct DLL *", & head);
  logVarInScope("local", "iter", "struct DLL *", & iter);
  logVarInScope("local", "new", "struct DLL *", & new);
  logVarInScope("local", "tmp", "void *", & tmp);
  logBlockEntry("leak-6-ptr.c", 47);
  dll_len = 40;
  dll_insert = dll_len / 2;
  tmp = malloc(sizeof(*head));
  logAssignNoOffset("leak-6-ptr.c", 50, & tmp, "void *", "tmp", tmp, "void", "malloc",
                    1);
  logMallocInfo("sizeof(*head)", sizeof(*head));
  head = (struct DLL *)tmp;
  logAssignNoOffset("leak-6-ptr.c", 50, & head, "struct DLL *", "head", head, "struct DLL",
                    "(struct DLL *)tmp", 0);
  head->next = (struct DLL *)((void *)0);
  logAssignOffset("leak-6-ptr.c", 51, head, "struct DLL", "*head", & head->next, "struct DLL *",
                  "head->next", head->next, "struct DLL", "(struct DLL *)((void *)0)",
                  0);
  head->prev = (struct DLL *)((void *)0);
  logAssignOffset("leak-6-ptr.c", 52, head, "struct DLL", "*head", & head->prev, "struct DLL *",
                  "head->prev", head->prev, "struct DLL", "(struct DLL *)((void *)0)",
                  0);
  iter = head;
  logAssignNoOffset("leak-6-ptr.c", 55, & iter, "struct DLL *", "iter", iter, "struct DLL",
                    "head", 0);
  i = 0;
  logBlockExit("leak-6-ptr.c", 59);
  while (i < dll_len) {
    logComment("Loop-iteration-start_leak-6-ptr.c_59");
    {
    new = malloc_node();
    logBlockEntry("leak-6-ptr.c", 60);
    logAssignNoOffset("leak-6-ptr.c", 60, & new, "struct DLL *", "new", new, "struct DLL",
                      "malloc_node", 0);
    dumpVarsOutOfScope();
    logBlockExit("", -1);
    if ((unsigned long )new == (unsigned long )((void *)0)) {
      exit(1);
    }
    insert_node(iter, new, (struct DLL *)((void *)0));
    logBlockEntry("", -1);
    dumpVarsOutOfScope();
    iter = new;
    logAssignNoOffset("leak-6-ptr.c", 66, & iter, "struct DLL *", "iter", iter, "struct DLL",
                      "new", 0);
    new = (struct DLL *)((void *)0);
    logAssignNoOffset("leak-6-ptr.c", 75, & new, "struct DLL *", "new", new, "struct DLL",
                      "(struct DLL *)((void *)0)", 0);
    i ++;
    logBlockExit("leak-6-ptr.c", 59);
    }
    logComment("Loop-iteration-end");
  }
  logBlockEntry("leak-6-ptr.c", 80);
  iter = head;
  logAssignNoOffset("leak-6-ptr.c", 80, & iter, "struct DLL *", "iter", iter, "struct DLL",
                    "head", 0);
  i___0 = 0;
  logBlockExit("leak-6-ptr.c", 82);
  while (i___0 < dll_insert) {
    logComment("Loop-iteration-start_leak-6-ptr.c_82");
    {
    logBlockEntry("leak-6-ptr.c", 83);
    iter = iter->next;
    logAssignNoOffset("leak-6-ptr.c", 83, & iter, "struct DLL *", "iter", iter, "struct DLL",
                      "iter->next", 0);
    i___0 ++;
    logBlockExit("leak-6-ptr.c", 82);
    }
    logComment("Loop-iteration-end");
  }
  logBlockEntry("leak-6-ptr.c", 86);
  iter->next = (struct DLL *)((void *)0);
  logAssignOffset("leak-6-ptr.c", 86, iter, "struct DLL", "*iter", & iter->next, "struct DLL *",
                  "iter->next", iter->next, "struct DLL", "(struct DLL *)((void *)0)",
                  0);
  logBlockExit("leak-6-ptr.c", 86);
  {
  logVarOutOfScope("argv", & argv);
  logVarOutOfScope("head", & head);
  logVarOutOfScope("iter", & iter);
  logVarOutOfScope("new", & new);
  logVarOutOfScope("tmp", & tmp);
  {
  logComment("Function Exited");
  return (0);
  }
  }
}
}
